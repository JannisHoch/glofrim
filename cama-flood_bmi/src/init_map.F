MODULE INIT_MAP_MOD
CONTAINS 
SUBROUTINE INIT_MAP
! ===============================================
! load map data
!    Author.
!     -------
!        EMANUEL DUTRA & DAI YAMAZAKI
!     Modifications.
!     --------------
!        Original : 2011-05-04
! ===============================================
USE PARKIND1   ,ONLY: JPIM, JPRB, JPRM
USE MOD_INPUT  ,ONLY: NULNAM, LOGNAM,TMPNAM,NX,NY,NLFP,IMIS,LOUTCDF,LOUTVEC,LMAPCDF,LMAPEND,&
                      CNEXTXY,CRIVCLINC,INPN,PMANRIV,PMANFLD, &
                      WEST, EAST, NORTH, SOUTH
USE MOD_MAP    ,ONLY: I2NEXTX,I2NEXTY,I2RIVSEQ,I2REGION, REGIONALL, REGIONTHIS, &
                      I1SEQX,I1SEQY,I1NEXT,I2VECTOR,NSEQRIV,NSEQALL,NSEQMAX,RIVSEQMAX, &
                      D1LON, D1LAT
USE MOD_INPUT  ,ONLY: LINTERP, CINPMAT,LINTERPCDF
USE MOD_MAP    ,ONLY: INPX, INPY, INPA
USE MOD_INPUT  ,ONLY: LPTHOUT,CPTHOUT
USE MOD_MAP    ,ONLY: NPTHOUT,NPTHLEV,PTH_UPST,PTH_DOWN,PTH_DST,PTH_ELV,PTH_WTH,PTH_MAN
USE MOD_OUTPUT ,ONLY: CSUFCDF, CSUFBIN, CSUFVEC
#ifdef UseCDF
USE NETCDF
USE LIB_NETCDF_UTIL
#endif

IMPLICIT NONE

INTEGER(KIND=JPIM)              :: IX,IY,JX,JY,ISEQ,IPTH,ILEV
#ifdef ConvEnd
INTEGER(KIND=JPIM)              :: INPI
#endif
REAL(KIND=JPRM),ALLOCATABLE     :: R2TMP(:,:,:)

#ifdef UseCDF
INTEGER(KIND=JPIM)              :: NCID,VARID
#endif
CHARACTER*128                   :: CFILE1, CFILE2

!!=============================
WRITE(LOGNAM,*) '*** INIT_MAP: calculate region ***'      

!! *** 1. ALLOCATE ARRAYS

ALLOCATE( I2NEXTX(NX,NY) )
ALLOCATE( I2NEXTY(NX,NY) )
ALLOCATE( I2RIVSEQ(NX,NY) )
ALLOCATE( I2REGION(NX,NY) )
ALLOCATE( I2VECTOR(NX,NY) )
ALLOCATE( D1LON(NX) )
ALLOCATE( D1LAT(NY) )
CALL READ_MAP

DO IX=1,NX
  D1LON(IX)=WEST+(DBLE(IX)-0.5)*(EAST-WEST)/REAL(NX)
ENDDO
DO IY=1,NY
  D1LAT(IY)=NORTH-(DBLE(IY)-0.5)*(NORTH-SOUTH)/REAL(NY)
ENDDO

WRITE(LOGNAM,*) 'INIT_MAP: calculate region'      !! Decide calculation regions for MPI run
CALL CALC_REGION

WRITE(LOGNAM,*) 'INIT_MAP: calculate 1d river sequence'
ALLOCATE(I1SEQX(NSEQMAX))
ALLOCATE(I1SEQY(NSEQMAX))
ALLOCATE(I1NEXT(NSEQMAX))

I1SEQX(:)=0
I1SEQY(:)=0
I1NEXT(:)=0

CALL CALC_1D_SEQ                                  !! 2D map to 1D vector conversion. for faster calculation

WRITE(LOGNAM,*) 'INIT_MAP: NSEQRIV=',NSEQRIV
WRITE(LOGNAM,*) 'INIT_MAP: NSEQALL=',NSEQALL

IF( REGIONTHIS==1 )THEN
  WRITE(LOGNAM,*) 'INIT_MAP: NSEQMAX=',NSEQMAX
  WRITE(LOGNAM,*) 'INIT_MAP: RIVSEQMAX=',RIVSEQMAX
ENDIF

IF( LOUTVEC )THEN
  WRITE(LOGNAM,*) 'INIT_MAP: WRTE_MAP2VEC'
  CALL WRTE_MAP2VEC
ENDIF

!! Write Map Data                                       !! used for combining mpi distributed output into one map
IF( REGIONTHIS==1 )THEN
  OPEN(TMPNAM,FILE='./mapdata.txt',FORM='FORMATTED')
  WRITE(TMPNAM,*) 'NX',        NX
  WRITE(TMPNAM,*) 'NY',        NY
  WRITE(TMPNAM,*) 'NLFP',      NLFP
  WRITE(TMPNAM,*) 'REGIONALL', REGIONALL
  WRITE(TMPNAM,*) 'NSEQMAX',   NSEQMAX
  CLOSE(TMPNAM)
ENDIF

                     !! runoff interpolation
IF( LINTERP )THEN
  WRITE(LOGNAM,*) 'INIT_MAP: INPUT MATRIX ', CINPMAT
  WRITE(LOGNAM,*) '  NX, NY, INPN =', NX, NY, INPN
  ALLOCATE(INPX(NX,NY,INPN),INPY(NX,NY,INPN),INPA(NX,NY,INPN),R2TMP(NX,NY,INPN))
  IF ( LINTERPCDF ) THEN 
#ifdef UseCDF
    CALL NCERROR (NF90_OPEN(CINPMAT,NF90_NOWRITE,NCID),'opening '//TRIM(CINPMAT) )

    WRITE(LOGNAM,*)'INIT_MAP: area:',TRIM(CINPMAT)
    CALL NCERROR ( NF90_INQ_VARID(NCID,'area',VARID),'getting id' )
    CALL NCERROR ( NF90_GET_VAR(NCID,VARID,INPA,(/1,1,1/),(/NX,NY,INPN/)),'reading data' ) 

    WRITE(LOGNAM,*)'INIT_MAP: indX:',TRIM(CINPMAT)
    CALL NCERROR ( NF90_INQ_VARID(NCID,'indX',VARID),'getting id' )
    CALL NCERROR ( NF90_GET_VAR(NCID,VARID,INPX,(/1,1,1/),(/NX,NY,INPN/)),'reading data' ) 

    WRITE(LOGNAM,*)'INIT_MAP: indY:',TRIM(CINPMAT)
    CALL NCERROR ( NF90_INQ_VARID(NCID,'indY',VARID),'getting id' )
    CALL NCERROR ( NF90_GET_VAR(NCID,VARID,INPY,(/1,1,1/),(/NX,NY,INPN/)),'reading data' ) 
#endif
  ELSE
    OPEN(TMPNAM,FILE=CINPMAT,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY*INPN)
    READ(TMPNAM,REC=1) INPX
    READ(TMPNAM,REC=2) INPY
    READ(TMPNAM,REC=3) R2TMP

#ifdef ConvEnd
    IF ( LMAPEND )THEN
      DO IY=1, NY
        DO IX=1, NX
          DO INPI=1, INPN
            CALL ENDIAN4(INPX(IX,IY,INPI))
            CALL ENDIAN4(INPX(IX,IY,INPI))
            CALL ENDIAN4(R2TMP(IX,IY,INPI))
          END DO
        END DO
      END DO
    ENDIF
#endif

    INPA(:,:,:)=DBLE(R2TMP(:,:,:))
    CLOSE(TMPNAM)
    DEALLOCATE(R2TMP)
  ENDIF
ENDIF


                     !! bifurcation channel
IF( LPTHOUT )THEN
  OPEN(TMPNAM,FILE=CPTHOUT,FORM='FORMATTED')
  READ(TMPNAM,*) NPTHOUT,NPTHLEV

  ALLOCATE(PTH_UPST(NPTHOUT))
  ALLOCATE(PTH_DOWN(NPTHOUT))

  ALLOCATE(PTH_DST(NPTHOUT))
  ALLOCATE(PTH_ELV(NPTHOUT,NPTHLEV))
  ALLOCATE(PTH_WTH(NPTHOUT,NPTHLEV))
  ALLOCATE(PTH_MAN(NPTHLEV))

  DO IPTH=1, NPTHOUT
    READ(TMPNAM,*) IX, IY, JX, JY, PTH_DST(IPTH), ( PTH_ELV(IPTH,ILEV),PTH_WTH(IPTH,ILEV),ILEV=1,NPTHLEV )
    PTH_UPST(IPTH)=I2VECTOR(IX,IY)
    PTH_DOWN(IPTH)=I2VECTOR(JX,JY)
  END DO

  DO ILEV=1, NPTHLEV
    IF( ILEV==1 )THEN
      PTH_MAN(ILEV)=PMANRIV
    ELSE
      PTH_MAN(ILEV)=PMANFLD
    ENDIF
  END DO

  CLOSE(TMPNAM)
ENDIF

CONTAINS


! ================================================
SUBROUTINE READ_MAP

IF ( .not. LMAPCDF ) THEN
  WRITE(LOGNAM,*)'INIT_MAP: nextXY file: ',TRIM(CNEXTXY)
  OPEN(TMPNAM,FILE=CNEXTXY,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY)
  READ(TMPNAM,REC=1) I2NEXTX
  READ(TMPNAM,REC=2) I2NEXTY
  CLOSE(TMPNAM)

#ifdef ConvEnd
  IF ( LMAPEND )THEN
    DO IY=1, NY
      DO IX=1, NX
        CALL ENDIAN4(I2NEXTX(IX,IY))
        CALL ENDIAN4(I2NEXTY(IX,IY))
      END DO
    END DO
  ENDIF
#endif

ELSE
#ifdef UseCDF
  CALL NCERROR (NF90_OPEN(CRIVCLINC,NF90_NOWRITE,NCID),'opening '//TRIM(CRIVCLINC) )

  WRITE(LOGNAM,*)'INIT_MAP: nextx:',TRIM(CRIVCLINC)
  CALL NCERROR ( NF90_INQ_VARID(NCID,'nextx',VARID),'getting id' )
  CALL NCERROR ( NF90_GET_VAR(NCID,VARID,I2NEXTX),'reading data' ) 

  WRITE(LOGNAM,*)'INIT_MAP: nexty:',TRIM(CRIVCLINC)
  CALL NCERROR ( NF90_INQ_VARID(NCID,'nexty',VARID),'getting id' )
  CALL NCERROR ( NF90_GET_VAR(NCID,VARID,I2NEXTY),'reading data' )

  WRITE(LOGNAM,*)'INIT_MAP: LAT:',TRIM(CRIVCLINC)
  CALL NCERROR ( NF90_INQ_VARID(NCID,'lat',VARID),'getting id' )
  CALL NCERROR ( NF90_GET_VAR(NCID,VARID,D1LAT),'reading data' )

  WRITE(LOGNAM,*)'INIT_MAP: LON:',TRIM(CRIVCLINC)
  CALL NCERROR ( NF90_INQ_VARID(NCID,'lon',VARID),'getting id' )
  CALL NCERROR ( NF90_GET_VAR(NCID,VARID,D1LON),'reading data' )

  CALL NCERROR( NF90_CLOSE(NCID))
#endif
ENDIF

CALL CALC_RIVSEQ

END SUBROUTINE READ_MAP


! ================================================
SUBROUTINE CALC_RIVSEQ
IMPLICIT NONE
INTEGER(KIND=JPIM) :: IX, IY, JX, JY, SEQNOW, NEXT

WRITE(LOGNAM,*) '  calculate river seqence'  
I2RIVSEQ(:,:)=1
DO IY=1, NY
  DO IX=1, NX
    IF( I2NEXTX(IX,IY)>0 )THEN
      JX=I2NEXTX(IX,IY)
      JY=I2NEXTY(IX,IY)
      I2RIVSEQ(JX,JY)=0
    ELSEIF( I2NEXTX(IX,IY)==-9999 )THEN
      I2RIVSEQ(IX,IY)=-9999
    ENDIF
  END DO
END DO

SEQNOW=0
NEXT=1
DO WHILE(NEXT>0 )
  SEQNOW=SEQNOW+1
  NEXT=0
  DO IY=1, NY
    DO IX=1, NX
      IF( I2RIVSEQ(IX,IY)==SEQNOW )THEN
        IF( I2NEXTX(IX,IY)>0 )THEN
          JX=I2NEXTX(IX,IY)
          JY=I2NEXTY(IX,IY)
          IF( I2RIVSEQ(JX,JY)<=SEQNOW )THEN
            NEXT=NEXT+1
            I2RIVSEQ(JX,JY)=SEQNOW+1
          ENDIF
        ENDIF
      ENDIF
    END DO
  ENDDO
END DO
RIVSEQMAX=SEQNOW
WRITE(LOGNAM,*) '  RIVSEQMAX = ', RIVSEQMAX


END SUBROUTINE CALC_RIVSEQ





!!==================================================
SUBROUTINE CALC_REGION    !! evenly allocate pixels to mpi nodes
IMPLICIT NONE

INTEGER(KIND=JPIM),ALLOCATABLE :: I2BASIN(:,:)
INTEGER(KIND=JPIM),ALLOCATABLE :: I2UPGRID(:,:)

INTEGER(KIND=JPIM),ALLOCATABLE :: BASINGRID(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: REGIONGRID(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: BASINREGION(:)

INTEGER(KIND=JPIM) :: IX,IY,JX,JY,KX,KY,UPG, BASINMAX, IREGION, JREGION, GRIDMIN, IBASIN

!!==============================

ALLOCATE(I2BASIN(NX,NY))
ALLOCATE(I2UPGRID(NX,NY))

WRITE(LOGNAM,*)'  calculate upstream grid number'
I2UPGRID(:,:)=0
DO IY=1, NY
  DO IX=1, NX
    IF( I2RIVSEQ(IX,IY)==1 ) THEN
      JX=IX
      JY=IY
      I2UPGRID(JX,JY)=1
      UPG=I2UPGRID(JX,JY)
      DO WHILE( I2NEXTX(JX,JY)>0 )  !! IF RIVER REACHES MOUTH, END LOOP
        KX=I2NEXTX(JX,JY)
        KY=I2NEXTY(JX,JY)
        JX=KX
        JY=KY
        IF( I2UPGRID(JX,JY)==0 )THEN               !! GRIDS FIRSTLY CHECKED
          I2UPGRID(JX,JY)=UPG+1
          UPG=I2UPGRID(JX,JY)
        ELSE                                       !! GRIDS ALREADY CHECKED
          I2UPGRID(JX,JY)=I2UPGRID(JX,JY)+UPG
        ENDIF
      END DO
    ENDIF
  END DO
END DO

WRITE(LOGNAM,*)'  calculate basin'
I2BASIN(:,:)=0
IBASIN=0
DO ISEQ=RIVSEQMAX, 1, -1
  DO IY=1, NY
    DO IX=1, NX
      IF( I2RIVSEQ(IX,IY)==ISEQ .AND. I2NEXTX(IX,IY)<0 .AND. I2RIVSEQ(IX,IY)/=IMIS )THEN
        IBASIN=IBASIN+1
        I2BASIN(IX,IY)=IBASIN
      ENDIF
    END DO
  END DO
END DO
BASINMAX=IBASIN

DO IY=1, NY
  DO IX=1, NX
    JX=IX
    JY=IY
    DO WHILE( I2BASIN(JX,JY)==0 .and. I2NEXTX(JX,JY)>0 )
      KX=I2NEXTX(JX,JY)
      KY=I2NEXTY(JX,JY)
      JX=KX
      JY=KY
    END DO
    IBASIN=I2BASIN(JX,JY)
    JX=IX
    JY=IY
    DO WHILE( I2BASIN(JX,JY)==0 .and. I2NEXTX(JX,JY)>0  )
      I2BASIN(JX,JY)=IBASIN
      KX=I2NEXTX(JX,JY)
      KY=I2NEXTY(JX,JY)
      JX=KX
      JY=KY
    END DO
  END DO
END DO

ALLOCATE(BASINGRID(BASINMAX))
ALLOCATE(BASINREGION(BASINMAX))
ALLOCATE(REGIONGRID(REGIONALL))

WRITE(LOGNAM,*)'  allocate basin to cpu (MPI)'
DO IY=1, NY
  DO IX=1, NX
    IF( I2NEXTX(IX,IY)<0 .and. I2NEXTX(IX,IY)/=IMIS )THEN
      IBASIN=I2BASIN(IX,IY)
      BASINGRID(IBASIN)=I2UPGRID(IX,IY)
    ENDIF
  END DO
END DO


REGIONGRID(:)=0
JREGION=1
DO IBASIN=1, BASINMAX
  GRIDMIN=NX*NY
  DO IREGION=1, REGIONALL
    IF( REGIONGRID(IREGION) < GRIDMIN )THEN
      GRIDMIN=REGIONGRID(IREGION)
      JREGION=IREGION
    ENDIF
  END DO
  BASINREGION(IBASIN)=JREGION
  REGIONGRID(JREGION)=REGIONGRID(JREGION)+BASINGRID(IBASIN)
END DO

NSEQMAX=0
DO IREGION=1, REGIONALL
  IF( REGIONTHIS==1 )THEN
    WRITE(NULNAM,*) 'CALC_REGION: ', IREGION, REGIONGRID(IREGION)
  ENDIF
  NSEQMAX=MAX(NSEQMAX,REGIONGRID(IREGION))
END DO

DO IY=1, NY
  DO IX=1, NX
    IF( I2BASIN(IX,IY)>0 .and. I2NEXTX(IX,IY)/=-9999 )THEN
      IBASIN=I2BASIN(IX,IY)
      I2REGION(IX,IY)=BASINREGION(IBASIN)
    ENDIF
  END DO
END DO

DEALLOCATE(BASINGRID)
DEALLOCATE(BASINREGION)
DEALLOCATE(REGIONGRID)

DEALLOCATE(I2BASIN)
DEALLOCATE(I2UPGRID)

END SUBROUTINE CALC_REGION


! ================================================
SUBROUTINE CALC_1D_SEQ
IMPLICIT NONE

I2VECTOR(:,:)=0
ISEQ=0
DO IY=1, NY
  DO IX=1, NX
    IF( I2NEXTX(IX,IY).GT.0 .and. I2REGION(IX,IY)==REGIONTHIS )THEN
      ISEQ=ISEQ+1
      I1SEQX(ISEQ)=IX
      I1SEQY(ISEQ)=IY
      I2VECTOR(IX,IY)=ISEQ
    ENDIF
  END DO
END DO
NSEQRIV=ISEQ

DO IY=1, NY
  DO IX=1, NX
    IF( I2NEXTX(IX,IY).LT.0 .AND. I2NEXTX(IX,IY).NE.IMIS .AND. I2REGION(IX,IY)==REGIONTHIS )THEN
      ISEQ=ISEQ+1
      I1SEQX(ISEQ)=IX
      I1SEQY(ISEQ)=IY
      I2VECTOR(IX,IY)=ISEQ
    ENDIF
  END DO
END DO
NSEQALL=ISEQ

DO ISEQ=1, NSEQALL
  IX=I1SEQX(ISEQ)
  IY=I1SEQY(ISEQ)
  IF( I2NEXTX(IX,IY)>0 )THEN
    JX=I2NEXTX(IX,IY)
    JY=I2NEXTY(IX,IY)
    I1NEXT(ISEQ)=I2VECTOR(JX,JY)
  ELSE
    I1NEXT(ISEQ)=-9
  ENDIF
END DO

END SUBROUTINE CALC_1D_SEQ


!!==================================================
SUBROUTINE WRTE_MAP2VEC       !! 1D sequence vector informtion required to convert vector output to 2D map

IMPLICIT NONE
#ifdef UseCDF
INTEGER(KIND=JPIM) :: XID,YID,LANDID
#endif

IF( LOUTCDF )THEN

  CFILE1='./region'//TRIM(CSUFCDF)
  CFILE2='./ind_xy'//TRIM(CSUFCDF)

#ifdef UseCDF
  IF( REGIONTHIS==1 )then

    CALL NCERROR( NF90_CREATE(CFILE1, NF90_64BIT_OFFSET, NCID) )
    !!== DIMENSIONS
    CALL NCERROR( NF90_DEF_DIM(NCID,'lon',   NX,   XID) )
    CALL NCERROR( NF90_DEF_DIM(NCID,'lat',   NY,   YID) )
    !!== VARIABLES
    CALL NCERROR( NF90_DEF_VAR(NCID, 'lon', NF90_FLOAT, (/XID/), VARID) ) !DONE
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','Longitude') )
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_east') )

    CALL NCERROR( NF90_DEF_VAR(NCID, 'lat', NF90_FLOAT, (/YID/), VARID) ) !DONE
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','Latitude') )
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_north') )

    CALL NCERROR( NF90_DEF_VAR(NCID, 'region', NF90_INT, (/XID,YID/), VARID) ) ! done
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','MPI Region') )
    CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','region index') )

    CALL NCERROR( NF90_ENDDEF(NCID) )
    !!== PUT VARS 
    CALL NCERROR( NF90_INQ_VARID(NCID,'lon',VARID))
    CALL NCERROR( NF90_PUT_VAR(NCID,VARID,D1LON))

    CALL NCERROR( NF90_INQ_VARID(NCID,'lat',VARID))
    CALL NCERROR( NF90_PUT_VAR(NCID,VARID,D1LAT))

    CALL NCERROR( NF90_INQ_VARID(NCID,'region',VARID))
    CALL NCERROR( NF90_PUT_VAR(NCID,VARID,I2REGION))

    CALL NCERROR( NF90_CLOSE(NCID) )
  ENDIF

  CALL NCERROR( NF90_CREATE(CFILE2,NF90_64BIT_OFFSET,NCID) )
  !!== DIMENSIONS
  CALL NCERROR( NF90_DEF_DIM(NCID, 'land', NSEQMAX, LANDID) )
  CALL NCERROR( NF90_DEF_DIM(NCID,'lon',   NX,   XID) )
  CALL NCERROR( NF90_DEF_DIM(NCID,'lat',   NY,   YID) )
    !!== VARIABLES
  CALL NCERROR( NF90_DEF_VAR(NCID, 'lon', NF90_FLOAT, (/XID/), VARID) ) !DONE
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','Longitude') )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_east') )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'lat', NF90_FLOAT, (/YID/), VARID) ) !DONE
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','Latitude') )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_north') )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'land', NF90_INT, (/LANDID/), VARID) ) ! done
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'compress','y x') )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'info','y/x index 1:ny(nx=1),ny+1:ny*2(nx=2),etc') )
  
  CALL NCERROR( NF90_DEF_VAR(NCID, 'land_ind', NF90_INT, (/XID,YID/), VARID) ) ! done
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','land index for x,y pairs') )
   
  CALL NCERROR( NF90_DEF_VAR(NCID, 'ind_x', NF90_INT, (/LANDID/), VARID) ) !done
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'compress','index X ') )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'ind_y', NF90_INT, (/LANDID/), VARID) ) !done
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'compress','index Y ') )

  CALL NCERROR( NF90_ENDDEF(NCID) )
  !!== PUT VARS
  CALL NCERROR( NF90_INQ_VARID(NCID,'ind_x',VARID))
  CALL NCERROR( NF90_PUT_VAR(NCID,VARID,I1SEQX))

  CALL NCERROR( NF90_INQ_VARID(NCID,'ind_y',VARID))
  CALL NCERROR( NF90_PUT_VAR(NCID,VARID,I1SEQY))
  
  CALL NCERROR( NF90_INQ_VARID(NCID,'land_ind',VARID))
  CALL NCERROR( NF90_PUT_VAR(NCID,VARID,I2VECTOR))

  CALL NCERROR( NF90_CLOSE(NCID) )
#endif

ELSE !! binary output
  CFILE1='./region'//TRIM(CSUFBIN)
  CFILE2='./ind_xy'//TRIM(CSUFVEC)

  IF( REGIONTHIS==1 )then
    OPEN(TMPNAM,FILE=CFILE1,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY)
    WRITE(TMPNAM,REC=1) I2REGION
    CLOSE(TMPNAM)
  ENDIF
  OPEN(TMPNAM,FILE=CFILE2,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NSEQMAX)
  WRITE(TMPNAM,REC=1) I1SEQX
  WRITE(TMPNAM,REC=2) I1SEQY
  CLOSE(TMPNAM)
ENDIF

END SUBROUTINE WRTE_MAP2VEC



END SUBROUTINE INIT_MAP
END MODULE INIT_MAP_MOD
