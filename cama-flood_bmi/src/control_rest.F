MODULE CONTROL_REST_MOD
CONTAINS 
SUBROUTINE CONTROL_REST(ISTEP,IYYYY,IMM,IDD)
! ===============================================
! control restart files
! ===============================================
USE PARKIND1   ,ONLY: JPIM, JPRB, JPRM
USE MOD_INPUT  ,ONLY: LOGNAM, TMPNAM, NX,NY, CRESTDIR, LRESTCDF, LSTOONLY, RESTFREQ,&
                      ISYEAR, ISMON,  ISDAY, RMIS, DMIS,LPTHOUT
USE MOD_TIME   ,ONLY: NSTEPS, KMIN,   KMINSTART, KHHMM
USE MOD_OUTPUT ,ONLY: CVNRESTART,CSUFBIN,CSUFCDF
USE MOD_MAP    ,ONLY: NSEQMAX, NPTHOUT, NPTHLEV,D1LON,D1LAT
USE MOD_PROG   ,ONLY: D2RIVSTO_OUT, D2FLDSTO_OUT, D2RIVOUT_PRE, D2FLDOUT_PRE, D1PTHFLW_PRE, D2RIVDPH_PRE, D2FLDSTO_PRE

IMPLICIT NONE

!!== INPUT
INTEGER(KIND=JPIM),INTENT(IN)  :: ISTEP,IYYYY,IMM,IDD

! ===============================================
IF ( .NOT. LRESTCDF )THEN
  IF ( RESTFREQ==0 .AND. IMM==1 .AND. IDD == 1 .AND. KHHMM == 0 ) CALL WRTE_REST_BIN  ! End of Year
  IF ( RESTFREQ==1 .AND. KHHMM .EQ. 0 ) CALL WRTE_REST_BIN                            ! DAILY
ELSEIF ( LRESTCDF ) THEN ! NETCDF RESTART 
  IF ( RESTFREQ .EQ. 0 .AND. ISTEP .EQ. NSTEPS ) CALL WRTE_REST_CDF  ! FINAL OF RUN
  IF ( RESTFREQ .EQ. 1 .AND. KHHMM .EQ. 0 ) CALL WRTE_REST_CDF       ! DAILY 
END IF 

CONTAINS





! ==================================================
SUBROUTINE WRTE_REST_BIN
IMPLICIT NONE
! 
REAL(KIND=JPRM)       :: R2TEMP(NX,NY)
REAL(KIND=JPRM)       :: R1PTH(NPTHOUT,NPTHLEV)
CHARACTER(LEN=256)    :: CFILE,CDATE


!!==============================

WRITE(CDATE,'(I4.4,2I2.2)') IYYYY, IMM, IDD

CFILE=TRIM(CRESTDIR)//TRIM(CVNRESTART)//TRIM(CDATE)//TRIM(CSUFBIN)
WRITE(LOGNAM,*) 'WRTE_REST: WRITE RESTART BIN:',CFILE

OPEN(TMPNAM,FILE=CFILE,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY)
  CALL VEC2MAP(D2RIVSTO_OUT,R2TEMP)
   WRITE(TMPNAM,REC=1) R2TEMP
  CALL VEC2MAP(D2FLDSTO_OUT,R2TEMP)
   WRITE(TMPNAM,REC=2) R2TEMP
  IF( .not. LSTOONLY )THEN
    CALL VEC2MAP(D2RIVOUT_PRE,R2TEMP)
     WRITE(TMPNAM,REC=3) R2TEMP
    CALL VEC2MAP(D2FLDOUT_PRE,R2TEMP)
     WRITE(TMPNAM,REC=4) R2TEMP
    CALL VEC2MAP(D2RIVDPH_PRE,R2TEMP)
     WRITE(TMPNAM,REC=5) R2TEMP
    CALL VEC2MAP(D2FLDSTO_PRE,R2TEMP)
     WRITE(TMPNAM,REC=6) R2TEMP
  ENDIF
CLOSE(TMPNAM)

IF( LPTHOUT )THEN
  IF( .not. LSTOONLY )THEN
    CFILE=TRIM(CRESTDIR)//TRIM(CVNRESTART)//TRIM(CDATE)//TRIM(CSUFBIN)//'.pth'
    WRITE(LOGNAM,*) 'WRTE_REST: WRITE RESTART BIN:',CFILE

    OPEN(TMPNAM,FILE=CFILE,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NPTHOUT*NPTHLEV)
    R1PTH(:,:)=REAL(D1PTHFLW_PRE(:,:))
    WRITE(TMPNAM,REC=1) R1PTH
    CLOSE(TMPNAM)
  ENDIF
ENDIF

END SUBROUTINE WRTE_REST_BIN







! ==================================================
SUBROUTINE WRTE_REST_CDF
#ifdef UseCDF
USE NETCDF
USE LIB_NETCDF_UTIL
IMPLICIT NONE
! 
CHARACTER(LEN=256)             :: CFILE,CDATE,CTIME,CVAR
INTEGER(KIND=JPIM)             :: NCID,VARID,LATID,LONID,TIMEID,JF
REAL(KIND=JPRB)                :: XTIME ! seconds since start of the run ! 
REAL(KIND=JPRB)                :: R2TEMP(NX,NY)

IF( LPTHOUT )THEN
  WRITE(LOGNAM,*) 'WRTE_REST: LPTHOUT IS ACTIVE, BUT WE DON NOT SAVE IT TO THE RESTART FILE!'
ENDIF 

XTIME=REAL( (KMIN-KMINSTART),JPRB) *60._JPRB
WRITE(CTIME,'(A14,I4.4,A1,I2.2,A1,I2.2,A6)') 'seconds since ',ISYEAR,'-',ISMON,'-',ISDAY,' 00:00'
WRITE(CDATE,'(I4.4,I2.2,I2.2)') IYYYY,IMM,IDD
CFILE=TRIM(CRESTDIR)//TRIM(CVNRESTART)//TRIM(CDATE)//TRIM(CSUFCDF)
WRITE(LOGNAM,*) 'WRTE_REST:create RESTART NETCDF:',CFILE
!! create netcdf file
CALL NCERROR( NF90_CREATE(CFILE,NF90_NETCDF4,NCID),'CREATING FILE:'//TRIM(CFILE) )

!! dimensions 
CALL NCERROR( NF90_DEF_DIM(NCID, 'time', NF90_UNLIMITED, TIMEID) )
CALL NCERROR( NF90_DEF_DIM(NCID, 'lat', NY, LATID) )
CALL NCERROR( NF90_DEF_DIM(NCID, 'lon', NX, LONID) )

!! variables: 
CALL NCERROR( NF90_DEF_VAR(NCID, 'lat', NF90_FLOAT, (/LATID/), VARID) )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','latitude') )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_north') )

CALL NCERROR( NF90_DEF_VAR(NCID, 'lon', NF90_FLOAT, (/LONID/), VARID) )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','longitude') )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units','degrees_east') )

CALL NCERROR( NF90_DEF_VAR(NCID, 'time', NF90_DOUBLE, (/TIMEID/), VARID) ) 
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name','time') )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',CTIME) )

CALL NCERROR( NF90_DEF_VAR(NCID, 'rivsto', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                          DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"river storage" ) )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3") )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS),'in here?' )

CALL NCERROR( NF90_DEF_VAR(NCID, 'fldsto', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                          DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')  
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"flood plain storage" ) )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3") )
CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS) )

IF( .not. LSTOONLY )THEN

  CALL NCERROR( NF90_DEF_VAR(NCID, 'rivout', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                            DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')  
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"river outflow" ) )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3/s") )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS) )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'fldout', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                            DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')  
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"floodplain outflow" ) )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3/s") )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS) )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'rivdph', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                            DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')  
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"river depth" ) )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m") )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS) )

  CALL NCERROR( NF90_DEF_VAR(NCID, 'fldsto_pre', NF90_DOUBLE, (/LONID,LATID,TIMEID/), VARID, &
                            DEFLATE_LEVEL=6,SHUFFLE=.True.), 'Creating Variable')  
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"floodplain storage prev" ) )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3") )
  CALL NCERROR( NF90_PUT_ATT(NCID, VARID, '_FillValue',DMIS) )

! CALL NCERROR( NF90_DEF_VAR(NCID, 'pthflw', NF90_DOUBLE, (/LANDID,TIMEID/), VARID) ) 
! CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'long_name',"floodpath outflow" ) )
! CALL NCERROR( NF90_PUT_ATT(NCID, VARID, 'units',"m3/s") )

ENDIF

CALL NCERROR( NF90_ENDDEF(NCID) )


CALL NCERROR( NF90_INQ_VARID(NCID,'time',VARID))
CALL NCERROR( NF90_PUT_VAR(NCID,VARID,XTIME) )

CALL NCERROR ( NF90_INQ_VARID(NCID,'lon',VARID),'getting id' )
CALL NCERROR( NF90_PUT_VAR(NCID,VARID,D1LON))

CALL NCERROR ( NF90_INQ_VARID(NCID,'lat',VARID),'getting id' )
CALL NCERROR( NF90_PUT_VAR(NCID,VARID,D1LAT))

DO JF=1,6
  SELECT CASE(JF)
    CASE (1)
        CVAR='rivsto'
        CALL VEC2MAPD(D2RIVSTO_OUT,R2TEMP)
    CASE (2)
        CVAR='fldsto'
        CALL VEC2MAPD(D2FLDSTO_OUT,R2TEMP)
    CASE (3)
        CVAR='rivout'
        CALL VEC2MAPD(D2RIVOUT_PRE,R2TEMP)
    CASE (4)
        CVAR='fldout'
        CALL VEC2MAPD(D2FLDOUT_PRE,R2TEMP)
    CASE (5)
        CVAR='rivdph'
        CALL VEC2MAPD(D2RIVDPH_PRE,R2TEMP)
    CASE (6)
        CVAR='fldsto_pre'
        CALL VEC2MAPD(D2FLDSTO_PRE,R2TEMP)
  END SELECT

  IF( (.not. LSTOONLY) .or. (JF<=2) )THEN
    CALL NCERROR( NF90_INQ_VARID(NCID,TRIM(CVAR),VARID))
    CALL NCERROR( NF90_PUT_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/)) )
  ENDIF
ENDDO

CALL NCERROR( NF90_SYNC(NCID) )
CALL NCERROR( NF90_CLOSE(NCID ) )

 
WRITE(LOGNAM,*) 'WRTE_REST: WRITE RESTART NETCDF:',CFILE
 
#endif
END SUBROUTINE WRTE_REST_CDF






! ================================================
SUBROUTINE VEC2MAP(D2VEC,R2MAP)
USE MOD_MAP    ,ONLY: I2VECTOR
IMPLICIT NONE

REAL(KIND=JPRB)              :: D2VEC(NSEQMAX,1)
REAL(KIND=JPRM)              :: R2MAP(NX,NY)

!$ SAVE
INTEGER(KIND=JPIM)           ::  IX,IY,ISEQ
!$OMP THREADPRIVATE(IX,ISEQ)
! ======

!$OMP PARALLEL DO
DO IY=1, NY
  DO IX=1, NX
    IF (I2VECTOR(IX,IY)>0) THEN
      ISEQ=I2VECTOR(IX,IY)
      R2MAP(IX,IY) = REAL(D2VEC(ISEQ,1))
    ELSE
      R2MAP(IX,IY) = RMIS
    END IF
  END DO
END DO
!$OMP END PARALLEL DO

END SUBROUTINE VEC2MAP

! ================================================
SUBROUTINE VEC2MAPD(D2VEC,R2MAP)
USE MOD_MAP    ,ONLY: I2VECTOR
IMPLICIT NONE

REAL(KIND=JPRB)              :: D2VEC(NSEQMAX,1)
REAL(KIND=JPRB)              :: R2MAP(NX,NY)

!$ SAVE
INTEGER(KIND=JPIM)           ::  IX,IY,ISEQ
!$OMP THREADPRIVATE(IX,ISEQ)
! ======
R2MAP(:,:) = DMIS
!$OMP PARALLEL DO
DO IY=1, NY
  DO IX=1, NX
    IF (I2VECTOR(IX,IY)>0) THEN
      ISEQ=I2VECTOR(IX,IY)
      R2MAP(IX,IY) = D2VEC(ISEQ,1)
    END IF
  END DO
END DO
!$OMP END PARALLEL DO

END SUBROUTINE VEC2MAPD

END SUBROUTINE CONTROL_REST
END MODULE CONTROL_REST_MOD
