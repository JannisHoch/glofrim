MODULE CONTROL_BOUND_MOD
CONTAINS 
SUBROUTINE CONTROL_BOUND(IYYYYP,IMMP,IDDP,KHHMMP)
! ===============================================
! control boundary condition at river mouth
! ===============================================

USE PARKIND1   ,ONLY: JPIM, JPRB, JPRM
USE MOD_INPUT  ,ONLY: LOGNAM, NX, NY, DT, DTBOUND, RMIS, LINPEND
USE MOD_INPUT  ,ONLY: LBOUNDSL, LBOUNDCDF, CBOUNDDIR, CBOUNDPRE, CBOUNDSUF, &
                      CBOUNDCDF, CBNDCDFVAR, SYEARBND, SMONBND, SDAYBND, &
                      NSTATIONS, CBOUNDREF
USE MOD_INPUT  ,ONLY: TMPNAM
USE MOD_MAP    ,ONLY: I2VECTOR,NSEQALL,NSEQMAX
USE MOD_TIME   ,ONLY: NSTEPS, KMINP
USE MOD_PROG   ,ONLY: D2BOUND
USE LIB_DATES  ,ONLY: DATE2MIN

#ifdef UseCDF
USE NETCDF
USE LIB_NETCDF_UTIL
#endif

!=================================================
implicit none
INTEGER(KIND=JPIM),INTENT(IN)    ::    IYYYYP,IMMP,IDDP,KHHMMP             !! date (start of time step)

!== LOCAL 
REAL(KIND=JPRM),ALLOCATABLE   ::  R2BOUNDIN(:,:)  ! for input boundary condition (m)

#ifdef UseCDF
INTEGER(KIND=JPIM)            ::  ISTEP, TIMEID, STATIONID
INTEGER(KIND=JPIM)            ::  NCID,VARID_SL,KMINCDFSTART,NCDFSTP
LOGICAL                       ::  LOPEN                               ! TRUE TO OPEN AND SETUP NETCDF FILE
SAVE NCID,VARID_SL,KMINCDFSTART,NCDFSTP,LOPEN     !! bugfix v362
DATA LOPEN /.TRUE./
#endif

!$ SAVE
INTEGER(KIND=JPIM)            ::  ISEQ
CHARACTER(LEN=256)            ::  CBOUNDNAME      !! input boundary file name
CHARACTER(LEN=256)            ::  CDAYTIME      

! ===============================================
#ifdef UseCDF
CALL INIT_BOUND_CDF
#endif
! ===============================================

DO ISEQ=1, NSEQALL
  D2BOUND(ISEQ,1)=0.D0
ENDDO

ALLOCATE( R2BOUNDIN(NX,NY) )
R2BOUNDIN(:,:)=0.D0

IF ( .not. LBOUNDCDF ) THEN
  CALL READ_BOUND_BIN
ELSE
  CALL READ_BOUND_CDF
ENDIF
    

DEALLOCATE(R2BOUNDIN)

CONTAINS


! =================================================
SUBROUTINE MAP2VEC(R2TEMP,D2VAR)
IMPLICIT NONE

REAL(KIND=JPRM)              :: R2TEMP(NX,NY)
REAL(KIND=JPRB)              :: D2VAR(NSEQMAX,1)
INTEGER(KIND=JPIM)           :: IX, IY


DO IY=1, NY
  DO IX=1, NX
    IF( I2VECTOR(IX,IY)>0 )THEN
      ISEQ=I2VECTOR(IX,IY)
      D2VAR(ISEQ,1)=DBLE(R2TEMP(IX,IY))
    ENDIF
  END DO
END DO

END SUBROUTINE MAP2VEC

SUBROUTINE READ_BOUND_BIN
WRITE(CDAYTIME,'(I4.4,I2.2,I2.2,I4.4)')IYYYYP,IMMP,IDDP,KHHMMP
CBOUNDNAME=TRIM(CBOUNDDIR)//TRIM(CBOUNDPRE)//TRIM(CDAYTIME)//TRIM(CBOUNDSUF)

WRITE(LOGNAM,*) "READ_BOUND_SL BIN:",TRIM(CBOUNDNAME)

OPEN(TMPNAM,FILE=CBOUNDNAME,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY)
READ(TMPNAM,REC=1) R2BOUNDIN
CALL MAP2VEC(R2BOUNDIN,D2BOUND)
CLOSE(TMPNAM)
END SUBROUTINE READ_BOUND_BIN

! ==================================================
SUBROUTINE READ_BOUND_CDF
#ifdef UseCDF
USE NETCDF
USE LIB_NETCDF_UTIL
IMPLICIT NONE

INTEGER(KIND=JPIM)  :: IREC, ISTAT
REAL(KIND=JPRM),ALLOCATABLE   ::  R1BOUNDIN(:)  ! 1D input boundary condition (m)
INTEGER(KIND=JPIM),ALLOCATABLE  :: R2BOUNDREF(:,:)
INTEGER(KIND=JPIM)           :: IX, IY
REAL(KIND=JPRM)     :: BOUNDVAL

IREC=(KMINP-KMINCDFSTART)*60_JPIM / int(DTBOUND,JPIM)  +1     !! (second from netcdf start time) / (input time step)
IF ( IREC == NCDFSTP + 1 ) THEN
  WRITE(LOGNAM,*) "!!! READ_BOUND_SL CDF:READING AGAIN LAST DAY !!!"
  IREC=IREC-1
ENDIF
WRITE(LOGNAM,*) "READ_BOUND_SL CDF:",TRIM(CBOUNDCDF)
WRITE(LOGNAM,*) "READ_BOUND_SL CDF:",KMINP,KMINCDFSTART,IREC

ALLOCATE( R2BOUNDREF(2,NSTATIONS) )
OPEN(TMPNAM,FILE=CBOUNDREF,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*2*NSTATIONS)
READ(TMPNAM,REC=1) R2BOUNDREF
CLOSE(TMPNAM)
ALLOCATE( R1BOUNDIN(NSTATIONS) )

CALL NCERROR( NF90_GET_VAR(NCID,VARID_SL,R1BOUNDIN,(/1,IREC/),(/NSTATIONS,1/)),'READING BOUNDARY SEA LEVEL' )

DO ISTAT=1,NSTATIONS
  IX=R2BOUNDREF(1,ISTAT)
  IY=R2BOUNDREF(2,ISTAT)
  IF( (IX .GT. 0) .AND. (IY .GT. 0) ) R2BOUNDIN(IX,IY)=R1BOUNDIN(ISTAT)
END DO
WRITE(LOGNAM,*) MAXVAL(R2BOUNDIN),MINVAL(R2BOUNDIN)
DEALLOCATE( R1BOUNDIN )



CALL MAP2VEC(R2BOUNDIN,D2BOUND)

#endif
END SUBROUTINE READ_BOUND_CDF



! =================================================
#ifdef UseCDF
SUBROUTINE INIT_BOUND_CDF

IF ( LBOUNDCDF .AND. LOPEN ) THEN
  LOPEN=.FALSE.

  CALL NCERROR( NF90_OPEN(CBOUNDCDF,NF90_NOWRITE,NCID),'OPENING :'//CBOUNDCDF )
  CALL NCERROR( NF90_INQ_VARID(NCID,CBNDCDFVAR,VARID_SL))
  CALL NCERROR( NF90_INQ_DIMID(NCID,'time',TIMEID),'GETTING TIME ID FORCING RUNOFF')
  CALL NCERROR( NF90_INQUIRE_DIMENSION(NCID=NCID,DIMID=TIMEID,LEN=NCDFSTP),'GETTING TIME LENGTH')

  ! SHOULD BE MODIFIED
  CALL NCERROR( NF90_INQ_DIMID(NCID,'stations',STATIONID),'GETTING STATION ID') 
  CALL NCERROR( NF90_INQUIRE_DIMENSION(NCID=NCID,DIMID=STATIONID,LEN=NSTATIONS),'GETTING STATION NUMBER')
  !
  KMINCDFSTART=DATE2MIN(SYEARBND*10000+SMONBND*100+SDAYBND,0)
  !! CHECK IF START IF OK 
  ISTEP=(KMINP-KMINCDFSTART)*60_JPIM/INT(DTBOUND,JPIM)+1
  IF ( ISTEP .LE. 0  ) THEN 
    WRITE(LOGNAM,*) "READ_BOUND CDF: RUNS STARTS EARLY THAN FORCING DATA"
    WRITE(LOGNAM,*) "READ_BOUND CDF: STP1,KMINP,KMINCDFSTART",ISTEP,KMINP,KMINCDFSTART
    STOP 9
  ENDIF
!  ISTEP=(KMINP+NSTEPS*INT(DT/60,JPIM)-KMINCDFSTART)*60_JPIM/INT(DTBOUND,JPIM)+1
  ISTEP=(KMINP+NSTEPS*INT(DT/60,JPIM)-KMINCDFSTART)*60_JPIM/INT(DTBOUND,JPIM)
  IF ( ISTEP .GT. NCDFSTP+1  ) THEN 
    WRITE(LOGNAM,*) "READ_BOUND CDF: RUNS ENDS LATTER THAN FORCING DATA"
    WRITE(LOGNAM,*) "READ_BOUND CDF: STP1,NCDFSTP",ISTEP,NCDFSTP
    STOP 9
  ENDIF
  WRITE(LOGNAM,*) "READ_BOUND CDF:",TRIM(CBOUNDCDF),'OPEN IN UNIT AND ID',NCID,VARID_SL
  WRITE(LOGNAM,*) "TIME LENGTH:",NCDFSTP
  WRITE(LOGNAM,*) "STATION NUMBER:",NSTATIONS
ENDIF

END SUBROUTINE INIT_BOUND_CDF
#endif

END SUBROUTINE CONTROL_BOUND
END MODULE CONTROL_BOUND_MOD
