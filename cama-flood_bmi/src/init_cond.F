MODULE INIT_COND_MOD
CONTAINS 
SUBROUTINE INIT_COND
! ===============================================
! set initial condition
! ===============================================
USE PARKIND1   ,ONLY: JPIM, JPRB, JPRM
USE MOD_INPUT  ,ONLY: LOGNAM,NX,NY,NLFP,DMIS,&
                      IRESTART,CRESTSTO,LRESTCDF,LSTOONLY,LPTHOUT
USE MOD_INPUT  ,ONLY: NXIN, NYIN
USE MOD_MAP    ,ONLY: NSEQMAX, NPTHOUT, NPTHLEV, I2VECTOR
USE MOD_PROG   ,ONLY: D2RIVSTO_IN, D2FLDSTO_IN, D2RIVOUT_IN, D2FLDOUT_IN, D1PTHFLW_IN
USE MOD_PROG   ,ONLY: D2RIVSTO_OUT,D2FLDSTO_OUT,D2RIVOUT_OUT,D2FLDOUT_OUT,D1PTHFLW_OUT, D2RUNOFF, &
                      D2RIVOUT_PRE,D2FLDOUT_PRE,D1PTHFLW_PRE,D2RIVDPH_PRE,D2FLDSTO_PRE
USE MOD_PROG   ,ONLY: D2FLDDPH_PRE,D2RIVSTO_PRE
USE MOD_PROG   ,ONLY: D2BOUND, R2ROFFIN, R2RUNOFF
#ifdef UseMPI
USE MOD_MAP    ,ONLY: REGIONTHIS
#endif

USE CALC_FLDSTG_MOD

IMPLICIT NONE

WRITE(LOGNAM,*) " "
WRITE(LOGNAM,*) "****INIT_COND: ****"

!!=============
!! 1. ALLOCATE 
ALLOCATE(R2ROFFIN(NXIN,NYIN))
ALLOCATE(R2RUNOFF(NX,NY))
ALLOCATE(D2RUNOFF(NSEQMAX,1))
ALLOCATE(D2BOUND(NSEQMAX,1))
ALLOCATE(D2RIVSTO_IN(NSEQMAX,1))
ALLOCATE(D2FLDSTO_IN(NSEQMAX,1))

ALLOCATE(D2RIVOUT_IN(NSEQMAX,1))
ALLOCATE(D2FLDOUT_IN(NSEQMAX,1))


ALLOCATE(D2RIVSTO_OUT(NSEQMAX,1))
ALLOCATE(D2FLDSTO_OUT(NSEQMAX,1))

ALLOCATE(D2RIVOUT_OUT(NSEQMAX,1))
ALLOCATE(D2FLDOUT_OUT(NSEQMAX,1))

ALLOCATE(D2RIVOUT_PRE(NSEQMAX,1))
ALLOCATE(D2FLDOUT_PRE(NSEQMAX,1))
ALLOCATE(D2RIVDPH_PRE(NSEQMAX,1))
ALLOCATE(D2FLDDPH_PRE(NSEQMAX,1))
ALLOCATE(D2FLDSTO_PRE(NSEQMAX,1))
ALLOCATE(D2RIVSTO_PRE(NSEQMAX,1))

ALLOCATE(D1PTHFLW_IN(NPTHOUT,NPTHLEV))
ALLOCATE(D1PTHFLW_OUT(NPTHOUT,NPTHLEV))
ALLOCATE(D1PTHFLW_PRE(NPTHOUT,NPTHLEV))
!!========================
!! 2. RESTART OR NOT ! 
IF ( IRESTART .EQ. 1 ) THEN
  IF ( LRESTCDF ) THEN
    CALL READ_REST_CDF
  ELSE
    CALL READ_REST_BIN
  ENDIF

  IF( LSTOONLY )THEN
    D2RIVOUT_OUT(:,:)=0._JPRB
    D2FLDOUT_OUT(:,:)=0._JPRB

    D2RIVOUT_PRE(:,:)=0._JPRB
    D2FLDOUT_PRE(:,:)=0._JPRB

    D2FLDSTO_PRE(:,:)=D2FLDSTO_OUT(:,:)
    D2RIVSTO_PRE(:,:)=D2RIVSTO_OUT(:,:)

    D1PTHFLW_OUT(:,:)=0._JPRB
    D1PTHFLW_PRE(:,:)=0._JPRB

    D2RIVDPH_PRE(:,:)=0._JPRB     !! bugfix v362
    D2FLDDPH_PRE(:,:)=0._JPRB
  ENDIF

ELSE
  ! SET TO ZERO ...
  WRITE(LOGNAM,*)'READ_REST: NO RESTART... SETTING TO ZERO'
  D2RIVSTO_OUT(:,:)=0._JPRB
  D2FLDSTO_OUT(:,:)=0._JPRB

  D2RIVOUT_OUT(:,:)=0._JPRB
  D2FLDOUT_OUT(:,:)=0._JPRB

  D2RIVOUT_PRE(:,:)=0._JPRB
  D2FLDOUT_PRE(:,:)=0._JPRB

  D2RIVDPH_PRE(:,:)=0._JPRB
  D2FLDDPH_PRE(:,:)=0._JPRB
  D2FLDSTO_PRE(:,:)=0._JPRB
  D2RIVSTO_PRE(:,:)=0._JPRB

  D1PTHFLW_OUT(:,:)=0._JPRB
  D1PTHFLW_PRE(:,:)=0._JPRB

  ! set initial water surface elevation to sea surface level
  CALL STORAGE_SEA_SURFACE

ENDIF

D2RIVSTO_IN(:,:)=D2RIVSTO_OUT(:,:)
D2FLDSTO_IN(:,:)=D2FLDSTO_OUT(:,:)
D2RIVOUT_IN(:,:)=D2RIVOUT_OUT(:,:)
D2FLDOUT_IN(:,:)=D2FLDOUT_OUT(:,:)
D1PTHFLW_IN(:,:)=D1PTHFLW_OUT(:,:)
R2ROFFIN(:,:)=0._JPRB
D2RUNOFF(:,:)=0._JPRB
D2BOUND(:,:)=0._JPRB

CONTAINS




! ==================================================
SUBROUTINE STORAGE_SEA_SURFACE
USE MOD_INPUT  ,ONLY: LMEANSL
USE MOD_MAP    ,ONLY: I1NEXT, NSEQALL
USE MOD_MAP    ,ONLY: D2RIVLEN, D2RIVWTH, D2ELEVTN, D2RIVELV, D2RIVHGT
USE MOD_MAP    ,ONLY: D2MEANSL
IMPLICIT NONE

INTEGER(KIND=JPIM) ::  ISEQ, JSEQ, KSEQ
REAL(KIND=JPRB)    ::  DSEAELV, DSEADPH

!!==============================
DO ISEQ=1, NSEQALL
  JSEQ=ISEQ
  DO WHILE( I1NEXT(JSEQ)>0 )
    KSEQ=JSEQ
    JSEQ=I1NEXT(KSEQ)
  END DO

  IF( LMEANSL )THEN
    DSEAELV=D2ELEVTN(JSEQ,1)+D2MEANSL(JSEQ,1)      !! mean sea level
  ELSE
    DSEAELV=D2ELEVTN(JSEQ,1)                     !! 0m boundary sea level
  ENDIF

  DSEADPH=MAX(DSEAELV-D2RIVELV(ISEQ,1),0._JPRB)
  DSEADPH=MIN(DSEADPH,D2RIVHGT(ISEQ,1))
  D2RIVSTO_OUT(ISEQ,1)=DSEADPH*D2RIVLEN(ISEQ,1)*D2RIVWTH(ISEQ,1)
END DO
    
END SUBROUTINE STORAGE_SEA_SURFACE






! ==================================================
SUBROUTINE READ_REST_BIN
USE MOD_INPUT ,ONLY: TMPNAM
IMPLICIT NONE

REAL(KIND=JPRM)     ::  R2TEMP(NX,NY)
REAL(KIND=JPRM)     :: R1PTH(NPTHOUT,NPTHLEV)
CHARACTER*128       ::  CFILE

#ifdef UseMPI
CHARACTER*2         ::  CTMP
#endif
!!==============================

CFILE=TRIM(CRESTSTO)

#ifdef UseMPI
  WRITE(CTMP,'(I2.2)') REGIONTHIS
  CFILE=TRIM(CRESTSTO)//'-'//TRIM(CTMP)
#endif

WRITE(LOGNAM,*)'READ_REST: read restart binary: ', TRIM(CFILE)
OPEN(TMPNAM,FILE=CFILE,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NX*NY)
READ(TMPNAM,REC=1) R2TEMP
 CALL MAP2VEC(R2TEMP,D2RIVSTO_OUT)
READ(TMPNAM,REC=2) R2TEMP
 CALL MAP2VEC(R2TEMP,D2FLDSTO_OUT)

IF ( .not. LSTOONLY )THEN
  READ(TMPNAM,REC=3) R2TEMP
   CALL MAP2VEC(R2TEMP,D2RIVOUT_PRE)
   D2RIVOUT_OUT=D2RIVOUT_PRE
  READ(TMPNAM,REC=4) R2TEMP
   CALL MAP2VEC(R2TEMP,D2FLDOUT_PRE)
   D2FLDOUT_OUT=D2FLDOUT_PRE
  READ(TMPNAM,REC=5) R2TEMP
   CALL MAP2VEC(R2TEMP,D2RIVDPH_PRE)
  READ(TMPNAM,REC=6) R2TEMP
   CALL MAP2VEC(R2TEMP,D2FLDSTO_PRE)
ENDIF
CLOSE(TMPNAM)


IF( LPTHOUT )THEN
  IF( .not. LSTOONLY )THEN
    CFILE=TRIM(CRESTSTO)//'.pth'
    WRITE(LOGNAM,*)'READ_REST: read restart binary: ', TRIM(CFILE)

    OPEN(TMPNAM,FILE=CFILE,FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4*NPTHOUT*NPTHLEV)
    READ(TMPNAM,REC=1) R1PTH
    D1PTHFLW_PRE(:,:)=R1PTH(:,:)
    CLOSE(TMPNAM)
  ENDIF
ENDIF

END SUBROUTINE READ_REST_BIN





! ==================================================
SUBROUTINE READ_REST_CDF     !! bugfix v362
#ifdef UseCDF
USE NETCDF
USE LIB_NETCDF_UTIL
USE MOD_MAP ,ONLY: NSEQMAX
IMPLICIT NONE

INTEGER(KIND=JPIM)    :: NCID,VARID
CHARACTER*128       ::  CFILE
REAL(KIND=JPRB)     ::  R2TEMP(NX,NY)

CFILE=TRIM(CRESTSTO)
WRITE(LOGNAM,*)'READ_REST: read restart netcdf: ', TRIM(CFILE)

CALL NCERROR( NF90_OPEN(CFILE,NF90_NOWRITE,NCID), 'OPENING '//CFILE)

CALL NCERROR( NF90_INQ_VARID(NCID,'rivsto',VARID))
CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
CALL MAP2VECD(R2TEMP,D2RIVSTO_OUT)

CALL NCERROR( NF90_INQ_VARID(NCID,'fldsto',VARID))
CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
CALL MAP2VECD(R2TEMP,D2FLDSTO_OUT)


IF( .not. LSTOONLY )THEN
  CALL NCERROR( NF90_INQ_VARID(NCID,'rivout',VARID))
  CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
  CALL MAP2VECD(R2TEMP,D2RIVOUT_PRE)
  D2RIVOUT_OUT=D2RIVOUT_PRE

  CALL NCERROR( NF90_INQ_VARID(NCID,'fldout',VARID))
  CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
  CALL MAP2VECD(R2TEMP,D2FLDOUT_PRE)
  D2FLDOUT_OUT=D2FLDOUT_PRE

  D1PTHFLW_PRE(:,:) = 0._JPRB
  D1PTHFLW_OUT(:,:)=D1PTHFLW_PRE(:,:)

  CALL NCERROR( NF90_INQ_VARID(NCID,'rivdph',VARID))
  CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
  CALL MAP2VECD(R2TEMP,D2RIVDPH_PRE)

  CALL NCERROR( NF90_INQ_VARID(NCID,'fldsto_pre',VARID))
  CALL NCERROR( NF90_GET_VAR(NCID,VARID,R2TEMP,(/1,1,1/),(/NX,NY,1/) ) )
  CALL MAP2VECD(R2TEMP,D2FLDSTO_PRE)

ENDIF

CALL NCERROR( NF90_CLOSE(NCID) )

#endif
END SUBROUTINE READ_REST_CDF



! =================================================
SUBROUTINE MAP2VEC(R2TEMP,D2VAR)
IMPLICIT NONE

REAL(KIND=JPRM)    :: R2TEMP(NX,NY)
REAL(KIND=JPRB)    :: D2VAR(NSEQMAX,1)
INTEGER(KIND=JPIM) :: IX, IY, ISEQ

DO IY=1, NY
  DO IX=1, NX
    IF( I2VECTOR(IX,IY)>0 )THEN
      ISEQ=I2VECTOR(IX,IY)
      D2VAR(ISEQ,1)=DBLE(R2TEMP(IX,IY))
    ENDIF
  END DO
END DO

END SUBROUTINE MAP2VEC


! =================================================
SUBROUTINE MAP2VECD(R2TEMP,D2VAR)  !! bugfix v362
IMPLICIT NONE

REAL(KIND=JPRB)    :: R2TEMP(NX,NY)
REAL(KIND=JPRB)    :: D2VAR(NSEQMAX,1)
INTEGER(KIND=JPIM) :: IX, IY, ISEQ

DO IY=1, NY
  DO IX=1, NX
    IF( I2VECTOR(IX,IY)>0 )THEN
      ISEQ=I2VECTOR(IX,IY)
      D2VAR(ISEQ,1)=(R2TEMP(IX,IY))
    ENDIF
  END DO
END DO

END SUBROUTINE MAP2VECD


END SUBROUTINE INIT_COND
END MODULE INIT_COND_MOD
