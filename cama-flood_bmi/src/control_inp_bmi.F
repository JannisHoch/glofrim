MODULE CONTROL_INP_BMI_MOD
CONTAINS 
SUBROUTINE CONTROL_INP_BMI
! ===============================================
! control input runoff
! ===============================================

USE PARKIND1   ,ONLY: JPIM, JPRB, JPRM
USE MOD_INPUT  ,ONLY: LOGNAM, NX, NY, NXIN, NYIN, INPN, DT, DTIN, DROFUNIT, LINTERP, LINPCDF, RMIS, LINPEND
USE MOD_INPUT  ,ONLY: CRUNOFFDIR, CRUNOFFPRE, CRUNOFFSUF, &
                      CRUNOFFCDF, CROFCDFVAR, SYEARIN, SMONIN, SDAYIN
USE MOD_MAP    ,ONLY: NSEQALL, NSEQMAX
USE MOD_TIME   ,ONLY: NSTEPS, KMINP
USE MOD_PROG   ,ONLY: D2RUNOFF, R2ROFFIN, R2RUNOFF
USE LIB_DATES  ,ONLY: DATE2MIN

!=================================================
implicit none

!== LOCAL 
INTEGER(KIND=JPIM)            ::  ISEQ

! ===============================================
!$OMP PARALLEL DO
DO ISEQ=1, NSEQALL
  D2RUNOFF(ISEQ,1)=0.D0
ENDDO
!$OMP END PARALLEL DO

WRITE(LOGNAM, *) "READ_RUNOFF VIA BMI"

! Interpolation & unit conversion (input runoff unit -> m3/sec)
IF( LINTERP )THEN
  CALL ROFF_INTERP(R2ROFFIN,D2RUNOFF)
ELSE
  CALL CONV_RESOL(R2ROFFIN,D2RUNOFF)
ENDIF

CALL VEC2MAP(D2RUNOFF, R2RUNOFF)

CONTAINS


! ================================================
SUBROUTINE VEC2MAP(D2VEC,R2MAP)
USE MOD_MAP    ,ONLY: I2VECTOR
IMPLICIT NONE

REAL(KIND=JPRB)              :: D2VEC(NSEQMAX,1)
REAL(KIND=JPRM)              :: R2MAP(NX,NY)

!$ SAVE
INTEGER(KIND=JPIM)           ::  IX,IY,ISEQ
!$OMP THREADPRIVATE(IX,ISEQ)
! ======
R2MAP(:,:) = RMIS
!$OMP PARALLEL DO
DO IY=1, NY
  DO IX=1, NX
    IF (I2VECTOR(IX,IY)>0) THEN
      ISEQ=I2VECTOR(IX,IY)
      R2MAP(IX,IY) = REAL(D2VEC(ISEQ,1))
    END IF
  END DO
END DO
!$OMP END PARALLEL DO

END SUBROUTINE VEC2MAP



! ================================================
SUBROUTINE ROFF_INTERP(R2ROFFIN,D2RUNOFF)
USE MOD_MAP    ,ONLY: I1SEQX, I1SEQY, NSEQALL
USE MOD_MAP    ,ONLY: INPX, INPY, INPA
IMPLICIT NONE

REAL(KIND=JPRM),INTENT(IN)  ::  R2ROFFIN(:,:)     !! mm/day
REAL(KIND=JPRB),INTENT(OUT) ::  D2RUNOFF(:,:)     !! m3/s

!$ SAVE
INTEGER(KIND=JPIM)  ::  ISEQ
INTEGER(KIND=JPIM)  ::  IX, IY, IXIN, IYIN, INPI  !! FOR OUTPUT
!$OMP THREADPRIVATE    (IX, IY, IXIN, IYIN, INPI)
! ================================================
!$OMP PARALLEL DO
DO ISEQ=1, NSEQALL
  IX=I1SEQX(ISEQ)
  IY=I1SEQY(ISEQ)
  D2RUNOFF(ISEQ,1)=0.D0
  DO INPI=1, INPN
    IXIN=INPX(IX,IY,INPI)
    IYIN=INPY(IX,IY,INPI)
    IF( IXIN>0 )THEN
      IF( IXIN > NXIN .OR. IYIN > NYIN ) THEN
        PRINT*, "error"
        PRINT*,'XXX',ISEQ,IX,IY,INPI,IXIN,IYIN
        CYCLE
      ENDIF
      IF( R2ROFFIN(IXIN,IYIN).NE.RMIS )THEN
        D2RUNOFF(ISEQ,1) = D2RUNOFF(ISEQ,1) + R2ROFFIN(IXIN,IYIN) * INPA(IX,IY,INPI) * DTIN**(-1.)  * DROFUNIT
        D2RUNOFF(ISEQ,1) = MAX(D2RUNOFF(ISEQ,1), 0.D0)
      ENDIF
    ENDIF
  END DO
  D2RUNOFF(ISEQ,1)=MAX(D2RUNOFF(ISEQ,1), 0.D0)
END DO
!$OMP END PARALLEL DO

RETURN
END SUBROUTINE ROFF_INTERP






! ================================================
SUBROUTINE CONV_RESOL(R2ROFFIN,D2RUNOFF)
USE MOD_MAP    ,ONLY: I1SEQX, I1SEQY, NSEQALL
USE MOD_MAP    ,ONLY: D2GRAREA
IMPLICIT NONE

REAL(KIND=JPRM),INTENT(IN)  ::  R2ROFFIN(:,:)     !! mm/day
REAL(KIND=JPRB),INTENT(OUT) ::  D2RUNOFF(:,:)     !! m3/s

INTEGER(KIND=JPIM)  ::  BY

!$ SAVE
INTEGER(KIND=JPIM)  ::  ISEQ
INTEGER(KIND=JPIM)  ::  IXIN, IYIN
!$OMP THREADPRIVATE    (IXIN, IYIN)
! ================================================
BY = NX/NXIN
!$OMP PARALLEL DO
DO ISEQ=1, NSEQALL
  IXIN=INT((I1SEQX(ISEQ)-1)/BY)+1
  IYIN=INT((I1SEQY(ISEQ)-1)/BY)+1
  IF( R2ROFFIN(IXIN,IYIN).NE.RMIS )THEN
    D2RUNOFF(ISEQ,1) = R2ROFFIN(IXIN,IYIN) * D2GRAREA(ISEQ,1) * DTIN**(-1.) * DROFUNIT
    D2RUNOFF(ISEQ,1) = MAX(D2RUNOFF(ISEQ,1), 0.D0)
  ELSE
    D2RUNOFF(ISEQ,1)=0.D0
  ENDIF
END DO
!$OMP END PARALLEL DO

RETURN
END SUBROUTINE CONV_RESOL

END SUBROUTINE CONTROL_INP_BMI
END MODULE CONTROL_INP_BMI_MOD
